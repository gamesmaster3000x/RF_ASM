{
	// Memory is allocated in blocks. This is a common implementation of the C malloc 
	// interface because it reduces the memory wastage from next-to-each-other
	// allocation and is also relatively fast.
	// The distribution of these blocks is important for the efficiency of the
	// algorithm. The sizes blocks here are distributed roughly by 4^x.

	// Region Rx starts at 'HeapOffset + 4*2^(x-2) + x*RegionMetaSize'
	// i.e. 
	//    R0 starts at HO + 4*1/4 + 0*RMS
	//    R1 starts at HO + 4*1/2 + 1*RMS
	//    R2 starts at HO + 4*1 + 2*RMS
	//    R3 starts at HO + 4*2 + 3*RMS

	// RMS = 1byte
	// Rx                   0     1        2              3
	//     HEAP OFFSET      ^     ^        ^              ^
	//   ~~~~~~~~~~~~~~~ 00 01 02 03 04 05 06 07 08 09 10 11 12 13 14 15 16
	//                   ^HO+0
	// 
	// R0: 4*1/4 + 0*1 = 1 + 0 = 1
	// R1: 4*1/2 + 1*1 = 2 + 1 = 3
	// R2: 4*1 + 2*1 = 4 + 2 = 6
	// R3: 4*2 + 3*1 = 8 + 3 = 11

	// !! IMPORTANT !!
	// This array should not be dynamically allocated!
	// It should be at a static location relative to the start of process memory.
	// int[] regions = new int[256];

	{

	#using "${NATIVE}/maths.crm" as maths

	// IMPORTANT!!
	// regions_i and regions_region will be removed!!
	// They should not be used and are purely for testing linking
	global int regions_i = 0;
	global int regions_length = 0;
	global int regions_region = 0;

	//
	// Return a pointer to a block of memory which is at least of the given size.
	//
	function int alloc (int size)
	{
		int i = 0;
		while (i < regions_length)
		{
			// Replace with regions[i]
			if ( regions_i == 0 ) // Region i is empty
			{
				regions_i = 1;
				int region_ptr = 0;
				region_ptr = get_region_ptr(r);
				return region_ptr;
			}
			i = i + 1;
		}
		return 0;
	}

	//
	// Return a pointer to the region given by index
	// This is given by the result of the calculation:
	//     HeapOffset + exponential_offset + r*RegionMetaSize;
	//
	function int get_region_ptr (int r)
	{
		// Need to calculate this before r changes later on
		int RRMS = r * RegionMetaSize;
		
		int exponential_offset = 4;
		
		// R<0 is not permitted
		if (r < 0) {
			// HELP!!!!
			// HOW DO I CRASH!?
		}
		
		// R=0 and R=1 would need 4*0.25 or 4*0.5 so we just handle them manually
		else if (r == 0) {
			exponential_offset = 1;
		}
		else if (r == 1) {
			exponential_offset = 2;
		}
		
		// R>=2 is calculated automatically
		else {
			while ( r > 0 ) {
				exponential_offset = exponential_offset * 2;
				r = r - 1;
			}
		}
		
		// Calculate final pointer value as in described equation
		int HO_EXP = HeapOffset + exponential_offset;
		int HO_EXP_RRMS = HO_EXP + RRMS;
		return HO_EXP_RRMS;
	}

	function null freeptr (int pointer)
	{
		int r = 0;
		int region_ptr = get_region_ptr(r);
		while ( pointer <  region_ptr )
		{
			r = r + 1;
			region_ptr = get_region_ptr(r);
		}
		freeregion(r);
	}

	function null freeregion (int region)
	{
		// Replace with regions[region]
		regions_region = 0;
	}
}